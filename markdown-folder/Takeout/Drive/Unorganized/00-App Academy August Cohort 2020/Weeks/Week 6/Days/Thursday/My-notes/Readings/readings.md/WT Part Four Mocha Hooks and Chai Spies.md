**

### Week 6 Aug 2020 Online {.sc-cSHVUG .VLQzD}

##### Tasks {.sc-chPdSV .iuEout}

-   ### Weekly Assessment {.sc-dnqmqq .kcAQXs}

    01:40:004/4**

    -   Quiz
        -   [*✔︎*Multiple Choice
            Quiz00:20:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/multiple-choice-quiz)
    -   Coding Problems
        -   [*✔︎*Define a
            Class00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/define-a-class)
        -   [*✔︎*Create a Parent
            Class00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/create-a-parent-class)
    -   Projects
        -   [*✔︎*Test-Driven
            Problems01:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/test-driven-problems)
-   ### Monday - HTTP {.sc-dnqmqq .kcAQXs}

    02:49:142/7**

    -   Learning Objectives
        -   [*●*HTTP Learning
            Objectives00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/http-learning-objectives)
    -   Lecture
        -   [*✔︎*HTTP
            Basics00:07:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/http-basics)
        -   [*✔︎*HTTP
            Requests00:08:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/http-requests)
        -   [*●*HTTP
            Responses00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/http-responses)
        -   [*►*Request-Response in the
            Browser00:10:12](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/request-response-in-the-browser)
        -   [*►*Your First
            Server00:09:02](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/your-first-server)
    -   Practices
        -   [*⬆︎*Build Your Own HTTP
            Server02:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/build-your-own-http-server)
-   ### Homework for Tuesday {.sc-dnqmqq .kcAQXs}

    00:35:000/3**

    -   Learning Objectives
        -   [*●*Promises Learning Objectives Day
            100:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises-learning-objectives-day-1)
    -   Homework
        -   [*●*A Mostly Complete Guide to Promises
            I00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/a-mostly-complete-guide-to-promises-i)
        -   [*●*A Mostly Complete Guide to Promises
            II00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/a-mostly-complete-guide-to-promises-ii)
-   ### Tuesday - Promises {.sc-dnqmqq .kcAQXs}

    04:44:082/5**

    -   Learning Objectives
        -   [*●*Promises Learning Objectives Day 1
            (Recall)00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises-learning-objectives-day-1--recall-)
    -   Lecture
        -   [*✔︎*Promises, Part
            100:15:02](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises--part-1)
        -   [*✔︎*Promises, Part
            200:10:12](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises--part-2)
        -   [*►*Fetch API Using
            node-fetch00:13:54](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/fetch-api-using-node-fetch)
    -   Practices
        -   [*⬆︎*Promise
            Project04:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promise-project)
-   ### Homework for Wednesday {.sc-dnqmqq .kcAQXs}

    01:33:002/5**

    -   Learning Objectives
        -   [*●*Promises Learning Objectives Day
            200:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises-learning-objectives-day-2)
        -   [*●*HTML Learning
            Objectives00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/html-learning-objectives)
    -   Homework
        -   [*✔︎*Modern Promises With async And
            await00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/modern-promises-with-async-and-await)
        -   [*✔︎*Revisiting the Basics of
            HTML00:08:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/revisiting-the-basics-of-html)
        -   [*●*Brushing Up On Your
            HTML01:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/brushing-up-on-your-html)
-   ### Wednesday - async and await {.sc-dnqmqq .kcAQXs}

    05:10:000/5**

    -   Learning Objectives
        -   [*●*Promises Learning Objectives Day 2
            (Recall)00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promises-learning-objectives-day-2--recall-)
        -   [*●*HTML Learning Objectives
            (Recall)00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/html-learning-objectives--recall-)
    -   Lecture
        -   [*►*Async and
            Await](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/async-and-await)
    -   Practices
        -   [*⬆︎*Exploring
            Promises01:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/exploring-promises)
        -   [*⬆︎*Trivia Game Three
            Ways04:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/trivia-game-three-ways)
-   ### Homework for Thursday {.sc-dnqmqq .jLQnpZ}

    01:22:000/8**

    -   Learning Objectives
        -   [*●*Testing
            Objectives00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/testing-objectives)
    -   Homework
        -   [*●*All about
            Testing00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/all-about-testing)
        -   [*●*Test-Driven
            Development00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/test-driven-development)
        -   [*●*JS Error
            Types00:07:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/js-error-types)
        -   [*●*Writing Tests (WT) Part One: Mocha and
            Assert00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/writing-tests--wt--part-one--mocha-and-assert)
        -   [*●*WT Part Two: Testing
            Errors00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/wt-part-two--testing-errors)
        -   [*●*WT Part Three: Testing Classes with
            Chai00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/wt-part-three--testing-classes-with-chai)
        -   [*●*WT Part Four: Mocha Hooks and Chai
            Spies00:15:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/wt-part-four--mocha-hooks-and-chai-spies)
-   ### Thursday - Unit Testing - Day 1 {.sc-dnqmqq .kcAQXs}

    04:31:310/11**

    -   Learning Objectives
        -   [*●*Testing Objectives
            (Recall)00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/testing-objectives--recall-)
    -   Lecture
        -   [*►*Automated Testing
            Introduction00:07:53](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/automated-testing-introduction)
        -   [*►*Reading Tests Code
            Demo00:19:37](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/reading-tests-code-demo)
        -   [*►*Writing Tests Code Demo Part
            One00:22:49](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/writing-tests-code-demo-part-one)
        -   [*►*Writing Tests Code Demo Part
            Two00:20:12](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/writing-tests-code-demo-part-two)
    -   Practices
        -   [*●*Flash Cards: JS
            Errors00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/flash-cards--js-errors)
        -   [*●*Flash Cards:
            TDD00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/flash-cards--tdd)
        -   [*★*TDD Workflow
            Quiz00:03:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/tdd-workflow-quiz)
        -   [*★*Writing Tests
            Quiz00:03:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/writing-tests-quiz)
        -   [*⬆︎*Reading Tests: Hanoi
            Game01:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/reading-tests--hanoi-game)
        -   [*⬆︎*Writing Tests: TDD
            Project02:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/writing-tests--tdd-project)
-   ### Homework for Friday {.sc-dnqmqq .kcAQXs}

    00:05:000/1**

    -   Homework
        -   [*★*Browser Basics
            Quiz00:05:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/browser-basics-quiz)
-   ### Friday - Unit Testing - Day 2 {.sc-dnqmqq .kcAQXs}

    05:10:000/9**

    -   Practices
        -   [*●*Project
            Overview00:10:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/project-overview)
        -   [*►*Building the Full-Stack To-Do
            List00:30:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/building-the-full-stack-to-do-list)
        -   [*●*Create and Serve the Category
            Screen00:30:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/create-and-serve-the-category-screen)
        -   [*●*Save Submitted Category
            Information00:30:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/save-submitted-category-information)
        -   [*●*Entering To-Do
            Items00:45:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/entering-to-do-items)
        -   [*●*Save and Show Submitted To-Do
            Items00:30:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/save-and-show-submitted-to-do-items)
        -   [*●*Completing a To-Do
            Item00:30:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/completing-a-to-do-item)
        -   [*●*Search For To-Do
            Items00:45:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/search-for-to-do-items)
        -   [*●*Refactor To Use a Template
            Engine01:00:00](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/refactor-to-use-a-template-engine)
-   ### Homework for Next Monday {.sc-dnqmqq .kcAQXs}

    0/1**

    -   Homework
        -   [*●*Study for your
            assessment!](https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/study-for-your-assessment-)

-   **

WT Part Four: Mocha Hooks and Chai Spies {.sc-kPVwWT .bRXTmH}
----------------------------------------

-   Profile
-   [**](https://launchpass.com/p/app-academy-mentor)
-   **
-   [**](https://forum.appacademy.io/)

WT Part Four: Mocha Hooks and Chai Spies {.sc-kIPQKe .erIitW}
========================================

-   ⏱ 15 minutes

-   Catalog**
-   Js Py Aug 2020 Online**
-   Week 6 Aug 2020 Online**
-   Wt Part Four Mocha Hooks And Chai Spies

Writing Tests
-------------

This will be the final demo in our writing tests series! In this reading
we'll be covering:

-   Using `Mocha`{.sc-cMljjf .hbDMZX} Hooks to DRY up testing
-   Using `Chai Spies`{.sc-cMljjf .hbDMZX} to "spy" on functions to see
    how many times they've been invoked

Part Four: Mocha Hooks and Chai Spies
-------------------------------------

Let's jump right back in. We've written some nice unit tests up to this
point:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("Dog Constructor Function", function() {
  it('should have a "name" property', function() {
    const layla = new Dog("Layla");
    expect(layla).to.have.property("name");
  });

  it('should set the "name" property when a new dog is created', function() {
    const layla = new Dog("Layla");
    // we are using the eql function to compare the value of layla.name
    // with the provided string
    expect(layla.name).to.eql("Layla");
  });
});
```

This is how unit tests are supposed to work, buuuut it will be annoying
over time if we have to define a new `Dog`{.sc-cMljjf .hbDMZX} instance
in *every single spec*. `Mocha`{.sc-cMljjf .hbDMZX} has some built in
functionality to help us with this problem though: Mocha Hooks!

### Introducing Mocha Hooks

[Mocha Hooks](https://mochajs.org/#hooks) give you a convenient way to
do set up prior to running a related group of specs or to do some clean
up after running those specs. Using hooks helps to keep your testing
code DRY so you don't unnecessarily repeat set up and clean up code
within each test.

Mocha Hooks have very descriptive function names and two levels of
granularity - before/after each block of tests *or* before/after each
test:

1.  the hooks `before`{.sc-cMljjf .hbDMZX} and `after`{.sc-cMljjf
    .hbDMZX} will be invoked either before or after the block of tests
    is run (depending on which function is used)
2.  the hooks `beforeEach`{.sc-cMljjf .hbDMZX} and
    `afterEach`{.sc-cMljjf .hbDMZX} will be invoked either before or
    after **each** test (depending on which function is used)

Let's look at a simple example that uses each of the available hooks to
log a message to the console. Two placeholder tests are also defined to
help demonstrate the differences between the available hooks:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
const assert = require('assert');

describe('Hooks demo', () => {
  before(() => {
    console.log('Before hook...');
  });

  beforeEach(() => {
    console.log('Before each hook...');
  });

  afterEach(() => {
    console.log('After each hook...');
  });

  after(() => {
    console.log('After hook...');
  });

  it('Placeholder one', () => {
    assert.equal(true, true);
  });

  it('Placeholder two', () => {
    assert.equal(true, true);
  });
});
```

Running the above spec produces the following output:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
  Hooks demo
Before hook...
Before each hook...
    ✓ Placeholder one
After each hook...
Before each hook...
    ✓ Placeholder two
After each hook...
After hook...


  2 passing (5ms)
```

Notice that the `before`{.sc-cMljjf .hbDMZX} and `after`{.sc-cMljjf
.hbDMZX} hooks only ran once while the `beforeEach`{.sc-cMljjf .hbDMZX}
and `afterEach`{.sc-cMljjf .hbDMZX} hooks each ran once per test.

Hooks are defined within a `describe`{.sc-cMljjf .hbDMZX} or
`context`{.sc-cMljjf .hbDMZX} function. While hooks can be defined
before, after, or interspersed with your tests, keeping all of your
hooks together (before or after your tests) will help others to read and
understand your code.

Defining hooks out of their logical order has no effect on when they're
ran. Consider the following example that defines an
`afterHook`{.sc-cMljjf .hbDMZX} before a `beforeEach`{.sc-cMljjf
.hbDMZX} hook:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
const assert = require('assert');

describe('Hooks demo', () => {
  afterEach(() => {
    console.log('After each hook...');
  });

  beforeEach(() => {
    console.log('Before each hook...');
  });

  it('Placeholder one', () => {
    assert.equal(true, true);
  });

  it('Placeholder two', () => {
    assert.equal(true, true);
  });
});
```

Running the above spec produces the following output:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
  Hooks demo
Before each hook...
    ✓ Placeholder one
After each hook...
Before each hook...
    ✓ Placeholder two
After each hook...


  2 passing (6ms)
```

The order of your hooks only matters when you define multiple hooks of
the same type. When a hook type is defined more than once, they'll be
ran in the order that they're defined in:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
const assert = require('assert');

describe('Hooks demo', () => {
  beforeEach(() => {
    console.log('Before each hook #1...');
  });

  beforeEach(() => {
    console.log('Before each hook #2...');
  });

  it('Placeholder one', () => {
    assert.equal(true, true);
  });

  it('Placeholder two', () => {
    assert.equal(true, true);
  });
});
```

Running the above spec produces the following output:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
  Hooks demo
Before each hook #1...
Before each hook #2...
    ✓ Placeholder one
Before each hook #1...
Before each hook #2...
    ✓ Placeholder two


  2 passing (5ms)
```

You can also define hooks within nested `describe`{.sc-cMljjf .hbDMZX}
or `context`{.sc-cMljjf .hbDMZX} functions:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
const assert = require('assert');

describe('Hooks demo', () => {
  before(() => {
    console.log('Before hook...');
  });

  beforeEach(() => {
    console.log('Before each hook...');
  });

  afterEach(() => {
    console.log('After each hook...');
  });

  after(() => {
    console.log('After hook...');
  });

  it('Placeholder one', () => {
    assert.equal(true, true);
  });

  it('Placeholder two', () => {
    assert.equal(true, true);
  });

  describe('nested tests', () => {
    before(() => {
      console.log('Nested before hook...');
    });
  
    beforeEach(() => {
      console.log('Nested before each hook...');
    });
  
    afterEach(() => {
      console.log('Nested after each hook...');
    });
  
    after(() => {
      console.log('Nested after hook...');
    });

    it('Placeholder one', () => {
      assert.equal(true, true);
    });
  
    it('Placeholder two', () => {
      assert.equal(true, true);
    });  
  });
});
```

Running the above spec produces the following output:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
  Hooks demo
Before hook...
Before each hook...
    ✓ Placeholder one
After each hook...
Before each hook...
    ✓ Placeholder two
After each hook...
    nested tests
Nested before hook...
Before each hook...
Nested before each hook...
      ✓ Placeholder one
Nested after each hook...
After each hook...
Before each hook...
Nested before each hook...
      ✓ Placeholder two
Nested after each hook...
After each hook...
Nested after hook...
After hook...


  4 passing (7ms)
```

Notice that the `before`{.sc-cMljjf .hbDMZX} and `after`{.sc-cMljjf
.hbDMZX} hooks defined in the top-level `describe`{.sc-cMljjf .hbDMZX}
function run only once while the `beforeEach`{.sc-cMljjf .hbDMZX} and
`afterEach`{.sc-cMljjf .hbDMZX} hooks run before and after
(respectively) for each of the tests defined in the top-level
`describe`{.sc-cMljjf .hbDMZX} function *and* for each of the tests
defined in the nested `describe`{.sc-cMljjf .hbDMZX} function.

> While the need to define nested hooks won't come up very often
> (especially when you're just starting out with unit testing), it is
> very helpful to be able to define a `beforeEach`{.sc-cMljjf .hbDMZX}
> hook in a top-level `describe`{.sc-cMljjf .hbDMZX} function that will
> run before every test in that block *and* before every test within
> nested `describe`{.sc-cMljjf .hbDMZX} or `context`{.sc-cMljjf .hbDMZX}
> functions (you'll do exactly that in just a bit).

You can also optionally pass a description for a hook or a named
function:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
beforeEach('My hook description', () => {
  console.log('Before each hook...');
});

beforeEach(function myHookName() {
  console.log('Before each hook...');
});
```

If an error occurs with executing the hook, the hook description or
function name will display in the console along with the error
information to assist with debugging.

### Using the `beforeEach`{.sc-cMljjf .hbDMZX} Mocha Hook

Let's go back to our spec and see how we can use hooks to DRY up our
code. Here's where we left off:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("Dog Constructor Function", function() {
  it('should have a "name" property', function() {
    const layla = new Dog("Layla");
    expect(layla).to.have.property("name");
  });

  it('should set the "name" property when a new dog is created', function() {
    const layla = new Dog("Layla");
    // we are using the eql function to compare the value of layla.name
    // with the provided string
    expect(layla.name).to.eql("Layla");
  });
});
```

Let's refactor our code to use a `beforeEach`{.sc-cMljjf .hbDMZX} hook
to assign the value of our new dog instance:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("Dog", function() {
  // we'll declare our variable here to ensure it's available within the scope
  // of all the specs below
  let layla;

  // now for each test below we'll create a new instance to ensure each of our
  // dog instances is exactly the same
  beforeEach("set up a dog instance", function() {
    layla = new Dog("Layla");
  });

  describe("Dog Constructor Function", function() {
    it('should have a "name" property', function() {
      expect(layla).to.have.property("name");
    });

    it('should set the "name" property when a new dog is created', function() {
      expect(layla.name).to.eql("Layla");
    });
  });
});
```

Now let's write a test from the next method on the `Dog`{.sc-cMljjf
.hbDMZX} class: `Dog.prototype.bark()`{.sc-cMljjf .hbDMZX}. For testing
classes we'll create a new `describe`{.sc-cMljjf .hbDMZX} function to
test each individual method. We'll now write our unit test inside taking
advantage of our `beforeEach`{.sc-cMljjf .hbDMZX} hook:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("Dog", function() {
  let layla;

  beforeEach("set up a dog instance", function() {
    layla = new Dog("Layla");
  });

  // etc, etc.

  describe("prototype.bark()", function() {
    it("should return a string with the name of the dog barking", function() {
      expect(layla.bark()).to.eql("Layla is barking");
    });
  });
});
```

Not only are we avoiding repeating our setup code within each test but
we've improved the readability of our code by making it more
self-descriptive. The code that runs before each test is literally
contained with a hook named `beforeEach`{.sc-cMljjf .hbDMZX}!

The `after`{.sc-cMljjf .hbDMZX} and `afterEach`{.sc-cMljjf .hbDMZX}
hooks are generally used less often than the `before`{.sc-cMljjf
.hbDMZX} and `beforeEach`{.sc-cMljjf .hbDMZX} hooks. Most of the time,
it's preferable to avoid using the `after`{.sc-cMljjf .hbDMZX} and
`afterEach`{.sc-cMljjf .hbDMZX} hooks to perform clean up tasks after
your tests. Instead, simply use the `before`{.sc-cMljjf .hbDMZX} and
`beforeEach`{.sc-cMljjf .hbDMZX} hooks to create a clean starting point
for each of your tests. Doing this will ensure that your tests run in a
consistent, predictable manner.

### Using Chai Spies

Sweet - let's now look to the next method on the
`Dog.prototype`{.sc-cMljjf .hbDMZX} -
`Dog.prototype.chainChaseTail`{.sc-cMljjf .hbDMZX}. This instance method
intakes a number (num) and will then invoke the
`Dog.prototype.chaseTail`{.sc-cMljjf .hbDMZX} function `num`{.sc-cMljjf
.hbDMZX} number of times. The `chaseTail`{.sc-cMljjf .hbDMZX} function
will just `console.log`{.sc-cMljjf .hbDMZX} a string - meaning that we
have no function output to test. The
`Dog.prototype.chainChaseTail`{.sc-cMljjf .hbDMZX} function will
additionally throw a `TypeError`{.sc-cMljjf .hbDMZX} if the incoming
argument is not a number.

We'll start by setting up our outer `describe`{.sc-cMljjf .hbDMZX} block
for the `prototype.chainChaseTail`{.sc-cMljjf .hbDMZX} method. Next
we'll add two `context`{.sc-cMljjf .hbDMZX} functions for our two
contexts - valid **or** invalid parameters:

> `context`{.sc-cMljjf .hbDMZX} is just an alias for
> `describe`{.sc-cMljjf .hbDMZX} it's just another way to make your
> tests more understandable and readable, in this case we are testing
> our method with different parameters, and thus in different contexts.
> (not to be confused with "context" in the javascript sense of the
> value of `this`{.sc-cMljjf .hbDMZX})

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("prototype.chainChaseTail()", function() {
  context("with an invalid parameter", function() {});
  context("with a valid number parameter", function() {});
});
```

We'll start by writing our test for when the method is invoked with
invalid parameters. To do this we'll use Chai's [`throw`{.sc-cMljjf
.hbDMZX}](https://www.chaijs.com/api/bdd/#method_throw) method ensuring
to wrap our error throwing function in another function:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
context("with an invalid parameter", function() {
  it("should throw a TypeError when given an argument that is not a number", function() {
    expect(() => layla.chainChaseTail("3")).to.throw(TypeError);
  });
});
```

> Note here we are passing the literal string `"3"`{.sc-cMljjf .hbDMZX}
> not the number 3.

Nice, now we can concentrate on our other context with a valid parameter
- and how to go about testing this function. In order to test
`chainChaseTail`{.sc-cMljjf .hbDMZX} properly we'll need to see *how
many times* the `chaseTail`{.sc-cMljjf .hbDMZX} method is invoked. Which
means we'll need to import another library that will add extra
functionality to `Chai`{.sc-cMljjf .hbDMZX}. We'll import the
[`Chai Spies`{.sc-cMljjf
.hbDMZX}](https://www.chaijs.com/plugins/chai-spies/) library using
`npm install chai-spies`{.sc-cMljjf .hbDMZX} in our top level directory.

Now we'll insert a few lines of code to the top of file to set up our
shiny new Chai Spies:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
// top of dog-spec.js
const chai = require("chai");
const expect = chai.expect;
const spies = require("chai-spies");
chai.use(spies);
```

We now have access to the `chai-spies`{.sc-cMljjf .hbDMZX} module in our
tests. The `Chai Spies`{.sc-cMljjf .hbDMZX} library provides a lot of
added functionality including the ability to determine if a function has
been called and how many times that function has been called.

So let's get started spying! We'll setup our `it`{.sc-cMljjf .hbDMZX}
function with an appropriate string:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
context("with a valid number parameter", function() {
  it("should call the chaseTail method n times", function() {});
});
```

Now in order to spy on a function we first need to tell Chai which
function we'd like to spy on using the `chai.spy.on`{.sc-cMljjf .hbDMZX}
method. In this case we'd like to spy on the instance of a Dog that will
be invoking the `chainChaseTail`{.sc-cMljjf .hbDMZX} method to determine
how many times the `chaseTail`{.sc-cMljjf .hbDMZX} method is then
invoked.

So we will set up our spy on the dog instance in question, as well as
tell our chai spy which method to keep track of:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
context("with a valid number parameter", function() {
  it("should call the chaseTail method n times", function() {
    // the first argument will be the instance we are spying on
    // the second argument will be the method we want to keep track of
    const chaseTailSpy = chai.spy.on(layla, "chaseTail");
  });
});
```

Now that our spy is set up we now need make sure our dog instance will
actually call the `chainChaseTail`{.sc-cMljjf .hbDMZX} function!
Otherwise our spy won't have anything to spy on:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
context("with a valid number parameter", function() {
  it("should call the chaseTail method n times", function() {
    const chaseTailSpy = chai.spy.on(layla, "chaseTail");
    // we need to invoke chainChaseTail because that is the method that
    // will invoke chaseTail which is the method we are spying on
    layla.chainChaseTail(3);
  });
});
```

Finally, we need to add our actual test - otherwise this is all for
naught! Chai has some really nice chaining methods when it comes to
checking how many times a function has been invoked. Here we'll use the
method chain of `expect(func).to.have.been.called.exactly(n)`{.sc-cMljjf
.hbDMZX} to test that the method we are spying on -
`chaseTail`{.sc-cMljjf .hbDMZX} was invoked a certain number of times:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
context("with a valid number parameter", function() {
  it("should call the chaseTail method n times", function() {
    const chaseTailSpy = chai.spy.on(layla, "chaseTail");
    layla.chainChaseTail(3);
    // below is our actual test to see how many times our spy was invoked
    expect(chaseTailSpy).to.have.been.called.exactly(3);
  });
});
```

### Testing static methods on classes

Sweet! We are almost done testing this class - just one more method to
go. We'll now work on testing the class method
`Dog.cleanDogs`{.sc-cMljjf .hbDMZX}. To denote that this is a class
method, not an instance method, our `describe`{.sc-cMljjf .hbDMZX}
string will not use the word `prototype`{.sc-cMljjf .hbDMZX}:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("cleanDogs()", function() {
  it("should return an array of each cleaned dog string", function() {});
});
```

Now the `Dog.cleanDogs`{.sc-cMljjf .hbDMZX} class method will intake an
array of dogs and output an array where each element is a string noting
that the passed in dog instance's paws are now clean. In order to
properly test this function we'll probably want an array of more than
one dog instance. Let's create a new dog and pass an array of two dog
instances to the `Dog.cleanDogs`{.sc-cMljjf .hbDMZX} method:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("cleanDogs()", function() {
  it("should return an array of each cleaned dog string", function() {
    const zoey = new Dog("Zoey");
    let cleanDogsArray = Dog.cleanDogs([layla, zoey]);
  });
});
```

Then we'll create a variable for our expected output and compare the
output we received from `Dog.cleanDogs`{.sc-cMljjf .hbDMZX}:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
describe("cleanDogs()", function() {
  it("should return an array of each cleaned dog string", function() {
    const zoey = new Dog("Zoey");
    let cleanDogsArray = Dog.cleanDogs([layla, zoey]);
    let result = ["I cleaned Layla's paws.", "I cleaned Zoey's paws."];
    expect(cleanDogsArray).to.eql(result);
  });
});
```

Awesome! We have fully testing the `Dog`{.sc-cMljjf .hbDMZX} class's
methods and learned a lot about testing along the way.

Here is our full testing file so you can ensure you got everything:

``` {style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"}
const chai = require("chai");
const expect = chai.expect;
const spies = require("chai-spies");
chai.use(spies);

// this is a relative path to the function location
const Dog = require("../problems/dog.js");

describe("Dog", function() {
  let layla;

  beforeEach("set up a dog instance", function() {
    layla = new Dog("Layla");
  });

  describe("Dog Constructor Function", function() {
    it('should have a "name" property', () => {
      expect(layla).to.have.property("name");
    });

    it('should set the "name" property when a new dog is created', () => {
      expect(layla.name).to.eql("Layla");
    });
  });

  describe("prototype.bark()", function() {
    it("should return a string with the name of the dog barking", () => {
      expect(layla.bark()).to.eql("Layla is barking");
    });
  });

  describe("prototype.chainChaseTail()", function() {
    context("with a valid number parameter", function() {
      it("should call the chaseTail method n times", function() {
        const chaseTailSpy = chai.spy.on(layla, "chaseTail");
        layla.chainChaseTail(3);

        expect(chaseTailSpy).to.have.been.called.exactly(3);
      });
    });

    context("with an invalid parameter", function() {
      it("should throw a TypeError when given an argument that is not a number", function() {
        expect(() => layla.chainChaseTail("3")).to.throw(TypeError);
      });
    });
  });

  describe("cleanDogs()", function() {
    it("should return an array of each cleaned dog string", function() {
      const zoey = new Dog("Zoey");
      let cleanDogsArray = Dog.cleanDogs([layla, zoey]);
      let result = ["I cleaned Layla's paws.", "I cleaned Zoey's paws."];
      expect(cleanDogsArray).to.eql(result);
    });
  });
});
```

What you learned
----------------

In the upcoming project we'll be covering a lot more Chai syntax - but
don't worry about memorizing this syntax! The point we are trying to
make is that in the future you'll be using a variety of software testing
frameworks and assertion libraries - the most important things are to
know the basics of how to structure tests as well as being able to read
and parse documentation to write tests.

In this series of readings we covered the basics of how to:

-   properly format and denote your mocha tests using
    `describe`{.sc-cMljjf .hbDMZX}, `context`{.sc-cMljjf .hbDMZX} and
    `it`{.sc-cMljjf .hbDMZX} blocks
-   write tests for individual functions as well as writing tests for
    classes
-   use `chai-spies`{.sc-cMljjf .hbDMZX} to test how many times a
    function has been called
-   test that functions will throw certain errors
-   recognize and utilize the Mocha hooks: `before`{.sc-cMljjf .hbDMZX},
    `beforeEach`{.sc-cMljjf .hbDMZX}, `after`{.sc-cMljjf .hbDMZX}, and
    `afterEach`{.sc-cMljjf .hbDMZX}

Did you find this lesson helpful?

No

Yes

✔︎ Mark As Complete

Finished with this task? Click **Mark as Complete** to continue to the
next page!


