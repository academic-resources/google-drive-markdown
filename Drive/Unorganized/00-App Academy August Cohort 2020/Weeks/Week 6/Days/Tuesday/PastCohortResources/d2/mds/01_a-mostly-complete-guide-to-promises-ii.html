<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>01_a-mostly-complete-guide-to-promises-ii</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="a-promise-is-a-promise-a-mostly-complete-guide-to-javascript-promises-ii">A Promise is a Promise: A Mostly Complete Guide to JavaScript Promises II</h1>
<p>This is part two of an article about classic JavaScript promises. If you have not read part one, we recommend that you navigate to the previous task to do so.</p>
<p>When you finish this article, you should be able to:</p>
<ul>
<li>Create your own <code>Promise</code>s</li>
<li>Use <code>Promise</code> objects returned by language and framework libraries</li>
</ul>
<h2 id="handling-success-with-then">Handling success with <code>then</code></h2>
<p>Returning to another file-reading example, consider the following block of code.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="at">readFile</span>(<span class="st">&quot;manifest.txt&quot;</span><span class="op">,</span> <span class="st">&quot;utf8&quot;</span><span class="op">,</span> (err<span class="op">,</span> manifest) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="va">console</span>.<span class="at">error</span>(<span class="st">&quot;Badness happened&quot;</span><span class="op">,</span> err)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="kw">const</span> fileList <span class="op">=</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> <span class="va">fileList</span>.<span class="at">length</span><span class="op">,</span> <span class="st">&quot;files&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>If this succeeds, then you would expect a statement like “Reading 12 files” to appear if the file contained a list of 12 files.</p>
<p>Now, to rewrite that using a <code>Promise</code> and printing that same statement, you would get a file-reading function that returns a <code>Promise</code> object. Later on, you’ll see how to create one for yourself. At this moment, just presume that a function named <code>readFilePromise</code> exists. When you call it, it would return a promise that, when <em>fulfilled</em>, would invoke the success handler registered for the object through the <code>then</code> method. Very explicitly, you could write that code like this.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/* EXPLICIT CODE: NOT FOR REAL USE */</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">// Declare a function that will handle the content of</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">// the file read by readFilePromise.</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">function</span> <span class="at">readFileSuccessHandler</span>(manifest) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="kw">const</span> fileList <span class="op">=</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> <span class="va">fileList</span>.<span class="at">length</span><span class="op">,</span> <span class="st">&quot;files&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">// Get a promise that will return the contents of the</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">// file.</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">const</span> filePromise <span class="op">=</span> <span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// Register a success handler to process the contents</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co">// of the file. In this case, it is the function</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">// defined above.</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="va">filePromise</span>.<span class="at">then</span>(readFileSuccessHandler)<span class="op">;</span></a></code></pre></div>
<p>Most <code>Promise</code>-based code does <strong>not</strong> look like that, though. Idiomatic JavaScript instructs to not create variables that don’t need to be created. You would see the above code in a real-live code base written like this, instead. Spend a moment comparing and contrasting the forms from <strong>very explicit</strong> to <strong>idiomatic</strong>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>).<span class="at">then</span>(manifest <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">const</span> fileList <span class="op">=</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> <span class="va">fileList</span>.<span class="at">length</span><span class="op">,</span> <span class="st">&quot;files&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>That’s slightly easier to read than the weird callback thing you had above. But, you still have that nasty double indentation. The designers of the <code>Promise</code> didn’t want that for you, so they allow you to chain <code>then</code>s.</p>
<h2 id="chaining-thens.">Chaining <code>then</code>s.</h2>
<p>In the above code that uses <code>readFilePromise</code>, it does not look like the ideal code that JavaScript could give us because of the success-handling function being on multiple lines that require another indent. It may be a little thing, but it still prevents you from the most readable code. Again, the Technical Committee 39 had your back. They designed “chainable thens” for you. The rules are a little complex to read.</p>
<ul>
<li>Each <code>Promise</code> has a <code>then</code> method that handles what happens when the <code>Promise</code> transitions out of the <strong>pending</strong> state.</li>
<li>Each <code>then</code> method returns a <code>Promise</code> that transitions out of its <strong>pending</strong> state when the <code>then</code> that created it completes.</li>
<li>(One more condition described below.)</li>
</ul>
<p>That chaining property gives you the ability to break apart the two lines of the success handler in the previous example to two one-line functions that do the same thing with less code! If you write that form explicitly, you’d have the following.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/* EXPLICIT CODE: NOT FOR REAL USE */</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// Get a Promise that fulfills when the file is read</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">// with the value of the content of the file.</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">const</span> filePromise <span class="op">=</span> <span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">// Register a success handler that takes the fulfilled</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">// value of the filePromise in the parameter named &quot;manifest&quot;,</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">// which is the content of the file, split it on newline</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">// characters, and return a Promise whose fulfilled value is</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">// list of lines.</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="kw">const</span> fileListPromise <span class="op">=</span> <span class="va">filePromise</span>.<span class="at">then</span>(manifest <span class="kw">=&gt;</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">// Register a success handler to the fileListPromise that</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">// receives the fulfilled value in the &quot;fileList&quot; parameter</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">// and returns a Promise whose fulfilled value is the length </span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co">// of the fileList array.</span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="kw">const</span> lengthPromise <span class="op">=</span> <span class="va">fileListPromise</span>.<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20"><span class="co">// Register a success handler to the lengthPromise that</span></a>
<a class="sourceLine" id="cb4-21" title="21"><span class="co">// receives the fulfilled value in the &quot;numberOfFiles&quot; parameter</span></a>
<a class="sourceLine" id="cb4-22" title="22"><span class="co">// and uses it to print the number of files to be read.</span></a>
<a class="sourceLine" id="cb4-23" title="23"><span class="va">lengthPromise</span>.<span class="at">then</span>(numberOfFiles <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb4-24" title="24">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> numberOfFiles<span class="op">,</span> <span class="st">&quot;files&quot;</span>)</a>
<a class="sourceLine" id="cb4-25" title="25">)<span class="op">;</span></a></code></pre></div>
<p>That code block has a lot of words to describe what happens at each step of the process of using “chainable thens”. In the real world, were you to find that code in a real application, it would likely look like the following.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)</a>
<a class="sourceLine" id="cb5-2" title="2">  .<span class="at">then</span>(manifest <span class="kw">=&gt;</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))</a>
<a class="sourceLine" id="cb5-3" title="3">  .<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">  .<span class="at">then</span>(numberOfFiles <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> numberOfFiles<span class="op">,</span> <span class="st">&quot;files&quot;</span>))<span class="op">;</span></a></code></pre></div>
<p>Here’s a diagram of what happens in the above code.</p>
<p>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/promises/assets/promise-success-diagram-source.svg" alt="promise errors" style="width: 100%; height: auto">
</p>
<p>You can see that each call to <code>then</code> creates a new <code>Promise</code> object that resolves to the value of the output of the previous success handler. That’s what happens when everything works out. What happens when it doesn’t?</p>
<h2 id="handling-failure-with-then">Handling failure with <code>then</code></h2>
<p>As you may recall from the section <a href="#so-what-is-a-promise">So, what is a “Promise”?</a>, you learned that the <code>then</code> method can also accept a second argument that is an error handler that takes care of things should something go wrong. Back to the file reading example from above, you add a second method to the <code>then</code> which accepts a <strong>reason</strong> that the error happened. For reading a file, that could be that the file doesn’t exist, the current user doesn’t have permissions to read it, or it ran out of memory trying to read a <em>huge</em> file.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>).<span class="at">then</span>(</a>
<a class="sourceLine" id="cb6-2" title="2">  manifest <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">const</span> fileList <span class="op">=</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> <span class="va">fileList</span>.<span class="at">length</span><span class="op">,</span> <span class="st">&quot;files&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb6-6" title="6">  reason <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="va">console</span>.<span class="at">error</span>(<span class="st">&quot;Badness happened&quot;</span><span class="op">,</span> reason)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb6-9" title="9">)<span class="op">;</span></a></code></pre></div>
<p>That works, but has taken you back to the original bad multiline form of the success handler. What happens if you did it like this? How does this work?</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">  .<span class="at">then</span>(</a>
<a class="sourceLine" id="cb7-3" title="3">    manifest <span class="kw">=&gt;</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb7-4" title="4">    reason <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">err</span>(<span class="st">&quot;Badness happened&quot;</span><span class="op">,</span> reason)</a>
<a class="sourceLine" id="cb7-5" title="5">  )</a>
<a class="sourceLine" id="cb7-6" title="6">  .<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb7-7" title="7">  .<span class="at">then</span>(numberOfFiles <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> numberOfFiles<span class="op">,</span> <span class="st">&quot;files&quot;</span>))<span class="op">;</span></a></code></pre></div>
<p>Here’s what happens with regard to the <code>Promise</code>s in this chain of <code>then</code>s.</p>
<p>
<img src="https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-JavaScript/promises/assets/promise-error-diagram-source.svg" alt="promise errors" style="width: 100%; height: auto">
</p>
<p>As you can see, the first <code>Promise</code> object from the <code>readFilePromise</code> function goes into the <strong>rejected</strong> state because, according to the error message, the file didn’t exist at the time the system tried to read it. That reason is represented as an object that has a code of “ENOENT” which a Unix error code and a message that provides a human-readable explanation of the error. That error reason object gets passed to the error handler of the first <code>then</code>. It’s what happens after that that is crazy neat.</p>
<p>The second <code>Promise</code> object is <strong>fulfilled</strong>! Because the first <code>then</code> doesn’t have any errors, because the error handler in the first then completes without any problem (printing out the error reason), the <code>Promise</code> returned by that <code>then</code> <em>does not</em> get <strong>rejected</strong>. Because of that, the <code>Promise</code> resolves with the value returned by the <code>console.error('Badness happened', err)</code> call. The <code>console.error</code> method returns <code>undefined</code>, so that becomes the value passed into the next <code>then</code> handler.</p>
<p>Because the second <code>then</code> success handler relies on an object with a <code>length</code> property, when it runs, an exception gets raised because the <code>undefined</code> value has no <code>length</code> property. This causes the <code>Promise</code> returned by the second <code>then</code> to become <strong>rejected</strong> because the code threw an exception.</p>
<p>Because that <code>Promise</code> is in the <strong>rejected</strong> state, it attempts to run the error handler of the next (third) <code>then</code>. There is no error handler. In the browser, it just looks like nothing happened. In Node.js, an <code>UnhandledPromiseRejectionWarning</code> is emitted to the console. In a future version of Node.js, it will cause the process to terminate with an exit code indicating an error bringing your service to a halt.</p>
<p>To correctly handle the exception of no file to read and still have all of the other lines of code run properly, you should write the following code.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)</a>
<a class="sourceLine" id="cb8-2" title="2">  .<span class="at">then</span>(manifest <span class="kw">=&gt;</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))</a>
<a class="sourceLine" id="cb8-3" title="3">  .<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb8-4" title="4">  .<span class="at">then</span>(</a>
<a class="sourceLine" id="cb8-5" title="5">    numberOfFiles <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> numberOfFiles<span class="op">,</span> <span class="st">&quot;files&quot;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-6" title="6">    reason <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">err</span>(<span class="st">&quot;Badness happened&quot;</span><span class="op">,</span> reason)</a>
<a class="sourceLine" id="cb8-7" title="7">  )<span class="op">;</span></a></code></pre></div>
<p>Now, if an error occurs, the chain of <code>then</code>s evaluates like this:</p>
<ol type="1">
<li>First <code>then</code>: I do not have an error handler. I will pass the error on and not run the success handler.</li>
<li>Second <code>then</code>: I do not have an error handler. I will pass the error on and not run the success handler.</li>
<li>Third <code>then</code>: I have an error handler and will run it.</li>
</ol>
<p>Now, the code looks almost like you’d imagined back in the <a href="#designing-a-better-solution">Designing a better solution</a> section. There’s still that annoying last double handler code that makes us use indentation and passing in two function objects to a <code>then</code> which looks kind of yucky. The Technical Committee gave you a solution for that, too.</p>
<blockquote>
<p><code>then</code> can handle both success and failures. The success handler is called with the value of the operation of the <code>Promise</code> when the <code>Promise</code> object transitions to the <strong>fulfilled</strong> state. If an error condition occurs, them the error handler of the <code>then</code> is called.</p>
<p>If a <code>Promise</code> object transitions to the <strong>rejected</strong> state and no error handler exists for the <code>then</code>, then that <code>then</code> is skipped altogether.</p>
<p>If an error handler is called and does not raise an exception, then the next <code>Promise</code> object transitions to the <strong>fulfilled</strong> state and the next success handler is called.</p>
</blockquote>
<h2 id="handling-failure-with-catch">Handling failure with <code>catch</code></h2>
<p>Rather than using a <code>then</code> with a success and error handler, you can use the similar <code>catch</code> method that takes just an error handler. By doing that, the code from the last section ends up looking like this.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" title="2">  .<span class="at">then</span>(manifest <span class="kw">=&gt;</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))</a>
<a class="sourceLine" id="cb9-3" title="3">  .<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">length</span>)</a>
<a class="sourceLine" id="cb9-4" title="4">  .<span class="at">then</span>(numberOfFiles <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading&quot;</span><span class="op">,</span> numberOfFiles<span class="op">,</span> <span class="st">&quot;files&quot;</span>))</a>
<a class="sourceLine" id="cb9-5" title="5">  .<span class="at">catch</span>(reason <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">err</span>(<span class="st">&quot;Badness happened&quot;</span><span class="op">,</span> reason))<span class="op">;</span></a></code></pre></div>
<p>That is exactly what the design expressed. The <code>catch</code> acts just like an error handler in the last <code>then</code>. If the <code>catch</code> doesn’t throw an exception, then it returns a <code>Promise</code> in a fulfilled state with whatever the return value is, just like the error handler of a <code>then</code>.</p>
<blockquote>
<p><code>catch</code> is a convenient way to do error handling in a <code>then</code> chain that looks kind of like part of a try/catch block.</p>
</blockquote>
<h2 id="using-promise.all-for-many-future-values">Using <code>Promise.all</code> for many future values</h2>
<p>You’re almost to the place where you can read the manifest file, get the list, and then count the characters in each of the files, and print out the result. You need to learn about two more features of JavaScript <code>Promise</code>s.</p>
<p>Imagine that you have three files that you want to read with the <code>readFilePromise</code> method. You want to wait until all three are done, but let them read files simultaneously. How do you manage all three <code>Promise</code>s as one <code>Promise</code>? That’s what the <code>Promise.all</code> method allows you to do.</p>
<p>For example, imagine you have the following array.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">const</span> values <span class="op">=</span> [</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="at">readFilePromise</span>(<span class="st">&quot;file-boop.txt&quot;</span>)<span class="op">,</span> <span class="co">// this is a Promise object: pending</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="at">readFilePromise</span>(<span class="st">&quot;file-doop.txt&quot;</span>)<span class="op">,</span> <span class="co">// this is a Promise object: pending</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="at">readFilePromise</span>(<span class="st">&quot;file-goop.txt&quot;</span>)<span class="op">,</span> <span class="co">// this is a Promise object: pending</span></a>
<a class="sourceLine" id="cb10-5" title="5">]<span class="op">;</span></a></code></pre></div>
<p>When you pass that array into <code>Promise.all</code>, it returns a <code>Promise</code> object that manages all of the <code>Promise</code>s in the array!</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">const</span> superPromise <span class="op">=</span> <span class="va">Promise</span>.<span class="at">all</span>(values)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">// superPromise is a Promise object in the pending state.</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">//</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">// Inside superPromise is an array of Promise objects</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co">// that look like this:</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">//</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">// 1. file reading promise in pending state, same as the one passed in</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co">// 2. file reading promise in pending state, same as the one passed in</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="co">// 3. file reading promise in pending state, same as the one passed in</span></a></code></pre></div>
<p>When all of the <code>Promise</code> objects in the super <code>Promise</code> transition out of the pending state, then the super <code>Promise</code> will also transition out of the pending state. If any one of the <code>Promise</code> objects in the array transition to the <strong>rejected</strong> state, then the super <code>Promise</code> will immediately transition to the <strong>rejected</strong> state with the same reason as the inner <code>Promise</code> failed with. If <em>all</em> of the internal <code>Promise</code> objects transition to the <strong>fulfilled</strong> state, then the super <code>Promise</code> will transition to the <strong>fulfilled</strong> state and its value will be an array of <em>all</em> of the resolved values of the original array.</p>
<p>With that in mind, you could continue the above code with a <code>then</code> and a <code>catch</code> that would demonstrate what happens.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1">superPromise</a>
<a class="sourceLine" id="cb12-2" title="2">  .<span class="at">then</span>(values <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(values))</a>
<a class="sourceLine" id="cb12-3" title="3">  .<span class="at">catch</span>(reason <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">error</span>(reason))<span class="op">;</span></a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">// If the function successfully reads the file, the values passed</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">// to the then come from the values that were in the superPromise</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">//</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">// 1. the content of file-boop.txt</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">// 2. the content of file-doop.txt</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co">// 3. the content of file-goop.txt</span></a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co">// If something goes wrong with reading the file, then the `catch`</span></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">// gets called with the error reason from the Promise object that</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co">// first failed.</span></a></code></pre></div>
<blockquote>
<p><code>Promise.all</code> accepts an array of values and returns a new <code>Promise</code> object in the <strong>pending</strong> state colloquially called a “super promise”. It converts all non-<code>Promise</code> values into <code>Promise</code> objects that are immediately in the <strong>fulfilled</strong> state. Then,</p>
<ul>
<li>If any one of the <code>Promise</code>s in the array transitions to the <strong>rejected</strong> state, then the “super promise” transitions to the <strong>rejected</strong> state with the same reason that the inner <code>Promise</code> object failed.</li>
<li>If all of the inner <code>Promise</code> objects in the array transition to the <strong>fulfilled</strong> state, then the “super promise” transitions to the <strong>fulfilled</strong> state with a value of an array populated, in order, of the resolved values of the original array.</li>
</ul>
</blockquote>
<h2 id="flattening-promises">Flattening <code>Promises</code></h2>
<p>The last thing you need to learn about <code>Promise</code>s is the coolest feature of them all. If you return a <code>Promise</code> object from either a success or error handler, the next step doesn’t get run until that <code>Promise</code> object resolves! Here’s what happens when you type the following code. It’s step 4 that is the amazing part.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="at">readFilePromise</span>(<span class="st">&quot;manifest.txt&quot;</span>)</a>
<a class="sourceLine" id="cb13-2" title="2">  .<span class="at">then</span>(manifestContent <span class="kw">=&gt;</span> <span class="va">manifestContent</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>))</a>
<a class="sourceLine" id="cb13-3" title="3">  .<span class="at">then</span>(manifestList <span class="kw">=&gt;</span> manifestList[<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb13-4" title="4">  .<span class="at">then</span>(fileName <span class="kw">=&gt;</span> <span class="at">readFilePromise</span>(fileName))</a>
<a class="sourceLine" id="cb13-5" title="5">  .<span class="at">then</span>(otherFileContent <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(otherFileContent))<span class="op">;</span></a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co">// Interpreted as:</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="co">// 1. Read the file of the manifest.txt file and pass the</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co">//    content to the first then.</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="co">// 2. Split the content from manifest.txt on newline chars</span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="co">//    to get the full list of files.</span></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="co">// 3. Return just the first entry in the list of files.</span></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="co">// 4. RETURN A PROMISE THAT WILL READ THE FILE NAMED ON THE</span></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">//    FIRST LINE OF THE manifest.txt! The next then method</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="co">//    doesn&#39;t get called until this Promise object completes!</span></a>
<a class="sourceLine" id="cb13-16" title="16"><span class="co">// 5. Get the content of the file just read and print it.</span></a></code></pre></div>
<p>Again, here’s the rule.</p>
<blockquote>
<p>If you return a <code>Promise</code> from a success or error handler, the next handler isn’t called until that <code>Promise</code> completes.</p>
</blockquote>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>You can now use all of this knowledge to use <code>Promise</code>s to read a manifest file, read each of the files in the manifest files, and count all of the characters in those files with code that reads much better than this.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="at">readFile</span>(<span class="st">&quot;manifest.txt&quot;</span><span class="op">,</span> <span class="st">&quot;utf8&quot;</span><span class="op">,</span> (err<span class="op">,</span> manifest) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="kw">const</span> fileNames <span class="op">=</span> <span class="va">manifest</span>.<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">const</span> characterCounts <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="kw">let</span> numberOfFilesRead <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="co">// Loop over each file name</span></a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="cf">for</span> (<span class="kw">let</span> fileName <span class="kw">of</span> fileNames) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="co">// Read that file&#39;s content</span></a>
<a class="sourceLine" id="cb14-9" title="9">    <span class="at">readFile</span>(fileName<span class="op">,</span> <span class="st">&quot;utf8&quot;</span><span class="op">,</span> (err<span class="op">,</span> content) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-10" title="10">      <span class="co">// Count the characters and store it in</span></a>
<a class="sourceLine" id="cb14-11" title="11">      <span class="co">// characterCounts</span></a>
<a class="sourceLine" id="cb14-12" title="12">      <span class="at">countCharacters</span>(characterCounts<span class="op">,</span> content)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-13" title="13"></a>
<a class="sourceLine" id="cb14-14" title="14">      <span class="co">// Increment the number of files read</span></a>
<a class="sourceLine" id="cb14-15" title="15">      numberOfFilesRead <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-16" title="16"></a>
<a class="sourceLine" id="cb14-17" title="17">      <span class="co">// If the number of files read is equal to the</span></a>
<a class="sourceLine" id="cb14-18" title="18">      <span class="co">// number of files to read, then print because</span></a>
<a class="sourceLine" id="cb14-19" title="19">      <span class="co">// we&#39;re done!</span></a>
<a class="sourceLine" id="cb14-20" title="20">      <span class="cf">if</span> (numberOfFilesRead <span class="op">===</span> <span class="va">fileNames</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-21" title="21">        <span class="va">console</span>.<span class="at">log</span>(characterCounts)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-22" title="22">      <span class="op">}</span></a>
<a class="sourceLine" id="cb14-23" title="23">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-25" title="25"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Remember that you’ve created a <code>countCharacters</code> methods elsewhere that does the grunt work of counting characters. So, now, if you were to list out the steps that you’d like to have the code perform, you should be able to write a <code>Promise</code>-based chain of <code>then</code>s that does that work.</p>
<ol type="1">
<li>Read <code>manifest.txt</code>.</li>
<li>Split the content into a list of files.</li>
<li>Read the contents of each file.</li>
<li>If all of them succeed, then
<ul>
<li>count the characters in each file and</li>
<li>print the character counts.</li>
</ul></li>
<li>If anything fails, print the error.</li>
</ol>
<p>So, in code, that you would translate that to the following.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">const</span> characterCounts <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="at">readFilePromise</span>(<span class="st">&#39;manifest.txt&#39;</span>)</a>
<a class="sourceLine" id="cb15-3" title="3">  .<span class="at">then</span>(fileContent <span class="kw">=&gt;</span> <span class="va">fileContent</span>.<span class="at">split</span>(<span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>))</a>
<a class="sourceLine" id="cb15-4" title="4">  .<span class="at">then</span>(fileList <span class="kw">=&gt;</span> <span class="va">fileList</span>.<span class="at">map</span>(fileName <span class="kw">=&gt;</span> <span class="at">readFilePromise</span>(fileName)))</a>
<a class="sourceLine" id="cb15-5" title="5">  .<span class="at">then</span>(lotsOfReadFilePromises <span class="kw">=&gt;</span> <span class="va">Promise</span>.<span class="at">all</span>(lotsOfReadFilePromises))</a>
<a class="sourceLine" id="cb15-6" title="6">  .<span class="at">then</span>(contentsArray <span class="kw">=&gt;</span> <span class="va">contentsArray</span>.<span class="at">forEach</span>(c <span class="kw">=&gt;</span> <span class="at">countCharacters</span>(characterCounts<span class="op">,</span> c))</a>
<a class="sourceLine" id="cb15-7" title="7">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(characterCounts))</a>
<a class="sourceLine" id="cb15-8" title="8">  .<span class="at">catch</span>(reason <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">error</span>(reason))<span class="op">;</span></a></code></pre></div>
<p>Through the magic of <code>Promise</code>s, you have now been able to do lots of asynchronous work but make it look synchronous!</p>
<h2 id="creating-your-own-promises">Creating your own <code>Promise</code>s</h2>
<p>Early on, you designed the way <code>Promise</code>s should work to look something like this.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="at">log</span>(<span class="st">&quot;Q&quot;</span>)</a>
<a class="sourceLine" id="cb16-2" title="2">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">log</span>(<span class="st">&quot;W&quot;</span>))</a>
<a class="sourceLine" id="cb16-3" title="3">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">pause</span>(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb16-4" title="4">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">log</span>(<span class="st">&quot;E&quot;</span>))</a>
<a class="sourceLine" id="cb16-5" title="5">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">log</span>(<span class="st">&quot;R&quot;</span>))</a>
<a class="sourceLine" id="cb16-6" title="6">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">pause</span>(<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb16-7" title="7">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="at">log</span>(<span class="st">&quot;T&quot;</span>))<span class="op">;</span></a></code></pre></div>
<p>That code uses two functions that you can define:</p>
<ul>
<li>a <code>log</code> function that takes a value to print and returns a <code>Promise</code> object that is in the <strong>fulfilled</strong> state; and,</li>
<li>a <code>pause</code> function that takes a number and returns a <code>Promise</code> object that, after the indicated number of seconds, transitions to the <strong>fulfilled</strong> state.</li>
</ul>
<p>Here is a way that you could create those functions.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">function</span> <span class="at">log</span>(message) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(message)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="cf">return</span> <span class="va">Promise</span>.<span class="at">resolve</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>The above function logs the message passed to it and, then creates a <code>Promise</code> object already transitioned to the <strong>fulfilled</strong> state. If you provide a value to the resolve method, then that becomes the value of the <code>Promise</code> object.†</p>
<p>The <code>pause</code> method is a little more difficult. You have to create a new <code>Promise</code> object from scratch to pause and then continue. To do that, you will use the <code>Promise</code> constructor.</p>
<p>The <code>Promise</code> constructor accepts a function that has two parameters. Each of those parameters will be functions, themselves. The first parameter is the so-called <strong>resolve</strong> parameter which, when called, transitions the <code>Promise</code> object to the <strong>fulfilled</strong> state. The second parameter is the so-called <strong>reject</strong> parameter which, when called, transitions the <code>Promise</code> object to the <strong>rejected</strong> state.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">function</span> <span class="at">pause</span>(numberOfSeconds) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="cf">return</span> <span class="kw">new</span> <span class="at">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="at">resolve</span>()<span class="op">,</span> numberOfSeconds <span class="op">*</span> <span class="dv">1000</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-4" title="4">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>As you can see from the above code, the <code>new Promise</code> gets a single argument, a two-parameter function that does some asynchronous thing. The two parameters are the <strong>resolve</strong> and the <strong>reject</strong> functions that you can use to transition the state of the <code>Promise</code> object being constructed. In this case, after a certain amount of time, the <code>resolve()</code> method is invoked which transitions the <code>Promise</code> object to the <strong>fulfilled</strong> state. The value is <code>undefined</code> because you’ve passed no value into the <code>resolve()</code> function invocation. If you wanted the <code>Promise</code> to have the value of 6.28, then you would invoke it like this <code>resolve(6.28)</code>. You can pass any one value into the <code>resolve</code> function, be it a number, a boolean, an array, an object, or whatever.</p>
<p>With that knowledge, think about how you would write a function using the <code>readFile</code> function that would return a <code>Promise</code> object that would resolve to the contents of the file on success and reject the <code>Promise</code> if an error occurred. Take a moment to scratch that out into an editor or something.</p>
<p>If you wrote something similar to the following, then you did a great job! If you didn’t, work through the following in a Node.js JavaScript environment to figure out how it works. You can use it like in any of the above examples.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">const</span> <span class="op">{</span> readFile <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&quot;fs&quot;</span>)<span class="op">;</span> <span class="co">// This is just the way to get</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="co">// the readFile method into the</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="co">// current file. If you don&#39;t</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="co">// understand it, that&#39;s ok.</span></a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="kw">function</span> <span class="at">readFilePromise</span>(path) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-7" title="7">  <span class="cf">return</span> <span class="kw">new</span> <span class="at">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="at">readFile</span>(path<span class="op">,</span> <span class="st">&quot;utf8&quot;</span><span class="op">,</span> (err<span class="op">,</span> content) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-9" title="9">      <span class="cf">if</span> (err) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-10" title="10">        <span class="at">reject</span>(err)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-11" title="11">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-12" title="12">        <span class="at">resolve</span>(content)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-13" title="13">      <span class="op">}</span></a>
<a class="sourceLine" id="cb19-14" title="14">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-16" title="16"><span class="op">}</span></a></code></pre></div>
<h2 id="what-youve-learned">What you’ve learned</h2>
<p>In this reading, you learned some fancy new things that let’s you turn asynchronous code into seemingly synchronous-looking code. You did that by learning that…</p>
<ul>
<li><code>then</code> can handle both success and failures. The success handler is called with the value of the operation of the <code>Promise</code> when the <code>Promise</code> object transitions to the <strong>fulfilled</strong> state. If an error condition occurs, them the error handler of the <code>then</code> is called.</li>
<li>If a <code>Promise</code> object transitions to the <strong>rejected</strong> state and no error handler exists for the <code>then</code>, then that <code>then</code> is skipped altogether.</li>
<li>If an error handler is called and does not raise an exception, then the next <code>Promise</code> object transitions to the <strong>fulfilled</strong> state and the next success handler is called.</li>
<li><code>catch</code> is a convenient way to do error handling in a <code>then</code> chain that looks kind of like part of a try/catch block.</li>
<li><code>Promise.all</code> accepts an array of values and returns a new <code>Promise</code> object in the <strong>pending</strong> state colloquially called a “super promise”. It converts all non-<code>Promise</code> values into <code>Promise</code> objects that are immediately in the <strong>fulfilled</strong> state. Then,
<ul>
<li>If any one of the <code>Promise</code>s in the array transitions to the <strong>rejected</strong> state, then the “super promise” transitions to the <strong>rejected</strong> state with the same reason that the inner <code>Promise</code> object failed.</li>
<li>If all of the inner <code>Promise</code> objects in the array transition to the <strong>fulfilled</strong> state, then the “super promise” transitions to the <strong>fulfilled</strong> state with a value of an array populated, in order, of the resolved values of the original array.</li>
</ul></li>
<li>If you return a <code>Promise</code> from a success or error handler, the next handler isn’t called until that <code>Promise</code> completes.</li>
<li>You can create a <strong>fulfilled</strong> <code>Promise</code> object by using the <code>Promise.resolve(value)</code> method.</li>
<li><p>You can create your own <code>Promise</code> objects from scratch by using the <code>Promise</code> constructor with the form</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">new</span> <span class="at">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="co">// do some async stuff</span></a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="co">// call resolve(value) to make the Promise succeed</span></a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="co">// call reject(reason) to make the Promise fail</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">Section: Promises, ECMAScript® 2015 Language Specification</a> is the minimum standard for how JavaScript Promises should act in <strong>all</strong> JavaScript environments. Language standards are dense and hard to read. You may want to give it a shot. The more you grow in your knowledge of how JavaScript works, the clearer it should become.</li>
<li><a href="https://promisesaplus.com/">The Promises/A+ Specification</a> has a very nice terse description of how Promises work. It is mostly the standard that was adopted by the Technical Committee 39 when including the <code>Promise</code> object into JavaScript.</li>
</ul>
<p>†: There’s a corresponding <code>Promise.reject(reason)</code> method that creates a <code>Promise</code> object immediately in the <strong>rejected</strong> state.</p>
</body>
</html>
