<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>promise project instructions</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <p>**</p>
    <ul>
      <li>Promise Project</li>
    </ul>
    <h1 id="curl-up-with-a-nice-promise">Curl Up With A Nice Promise</h1>
    <p>
      You’ve learned about how to use Promise objects to help master the
      problems of asynchronous program logic. Now, you can really get your hands
      dirty by building a Node.js-based version of the popular
      <a href="https://curl.haxx.se/">curl</a> utility!
    </p>
    <p>
      You may not know, but <code>curl</code> is a command line program to get
      the <code>c</code>ontent at <code>URL</code>. <code>cURL</code>. Get it?
    </p>
    <h2 id="this-project">This project</h2>
    <p>
      You will create a version of the <code>curl</code> utility that will be
      able to
    </p>
    <ul>
      <li>Download content from the Internet</li>
      <li>Save it into files</li>
      <li>Modify the HTTP request using command-line arguments</li>
      <li>Send data with the HTTP request</li>
      <li>Save the metadata of the HTTP response</li>
    </ul>
    <h2 id="getting-started">Getting started</h2>
    <p>
      To get started, create a project directory, create file in it named
      “curl.js”, and open it up in Visual Studio Code.
    </p>
    <p>Now, use the <code>npm</code> command to install “node-fetch”.</p>
    <h3 id="a-word-about-fetch">A word about fetch</h3>
    <p>
      The <code>fetch</code> command allows you to call another server or
      service hosted on the web and returns you the results.
    </p>
    <p>
      <strong
        >Since<code>fetch</code> is asynchronous, you will need to use a promise
        to handle the response when it returns from the remote server.</strong
      >
    </p>
    <p>
      Specifically, <code>fetch</code> makes HTTP requests for XML, JSON, text,
      files or any content that can be sent through the REST protocol.
    </p>
    <p>
      The <strong>node-fetch</strong> package includes a <code>fetch</code>
      <strong>function which has two arguments</strong>:
    </p>
    <p><strong>a url and an options object</strong>.</p>
    <p>
      This function <strong>returns a promise</strong>. The promise is what
      allows you to
      <strong>wait for the response and <code>then</code> handle it</strong>.
    </p>
    <p>
      The
      <strong
        >response from the fetch promise includes a <code>text()</code> function
        that also returns a promise</strong
      >. That is because the text can stream when it’s long streaming is when
      the first part is available after a short time and the rest continues to
      load in the background.
    </p>
    <p>
      To learn more about using fetch within NodeJS, you may look at the npm
      page for
      <a href="https://www.npmjs.com/package/node-fetch">node-fetch</a>,
      specifically the
      <a
        href="https://open.appacademy.io/learn/js-py---aug-2020-online/week-6-aug-2020-online/promise-project"
        >section on fetch</a
      >
      and
      <a href="https://www.npmjs.com/package/node-fetch#bodytext"
        >section on body text</a
      >, or additional documentation such as
      <a href="https://flaviocopes.com/fetch-api/#body-content">body content</a>
      and
      <a href="https://flaviocopes.com/fetch-api/#catching-errors"
        >catching errors</a
      >.
    </p>
    <h3 id="as-you-go-along">As you go along</h3>
    <p>
      Every new feature that you add should <em>not</em> break a
      previously-implemented feature. If your utility can print out a file to
      the console and then it doesn’t after you add the “save to a file”
      feature, you broke it. Make sure everything works every time you do
      something new.
    </p>
    <p>
      A good way to help with this is to initialize a Git repository at the
      beginning of your project. Then, whenever you get something to work, add
      and commit those changes. That way, you can get yourself out of an “oh,
      geez, I really messed it up right now” moment by doing something like
      <code>git checkout -- .</code>.
    </p>
    <h2 id="step-1-just-getting-a-url">Step 1: Just getting a URL</h2>
    <p>
      The first feature that you need to support is making a normal GET request
      to a URL and printing out the content to “standard out” (console.logging
      it).
    </p>
    <p>
      This service is a great starting point:
      <a href="https://artii.herokuapp.com/make?text=curl++this"
        >https://artii.herokuapp.com/make?text=curl++this</a
      >
    </p>
    <p>
      It points to the ASCII art API. It takes some text in the URL and turns it
      into ASCII art. You can try it in standard
      <code class="sc-cMljjf hbDMZX">curl</code> if you’d like to see how it
      works before you write your code. In you terminal, run this command.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; curl
        https://artii.herokuapp.com/make?text=curl++this</code
      >
    </p>
    <p>
      Now write code in your <strong>curl.js</strong> file to make the fetch
      call using a promise to grab the result and log it out to the console.
    </p>
    <blockquote>
      <p>
        Tip: Put the above url into a constant or variable as you’ll be
        replacing it soon with a command-line parameter.
      </p>
    </blockquote>
    <p>When you run your program you should see the following.</p>
    <p>
      ``` {style=“color: rgb(248, 248, 242); background: rgb(45, 45, 45);
      font-family: Consolas, Monaco,”Andale Mono“,”Ubuntu Mono“, monospace;
      text-align: left; white-space: pre; word-spacing: normal; word-break:
      normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
      none; padding: 1em; overflow: auto; font-size: 16px;”} &gt; node curl.js
      https://artii.herokuapp.com/make?text=curl++this _ _ _
      <em> | | | | | | (</em>) ___ _ _ _
      <strong
        >| | | |<em>| |<strong> _ </strong></em> / </strong
      >| | | | ‘<strong>| | | </strong>|’_ | / <strong>| | (</strong>| |<em
        >| | | | | | |</em
      >| | | | __<br />
      _<strong>|_<em>,</em>|<em>| |</em>| _<em>|</em>| |<em>|</em>|</strong>_/
    </p>
    <blockquote>
      <p>```</p>
    </blockquote>
    <p>Congrats! That’s ASCII art. :)</p>
    <h3 id="just-failing-to-get-a-url">Just failing to get a URL</h3>
    <p>
      Let’s say the host server doesn’t exist. You should handle that
      gracefully. You’re using Promises. That means this probably goes in a
      <code class="sc-cMljjf hbDMZX">catch</code> handler somewhere.
    </p>
    <p>
      Since you are emulating the
      <code class="sc-cMljjf hbDMZX">curl</code> command, you can see what it
      does with an invalid url.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; curl
        https://artii.herokuFLAP.com/make?text=curl++this curl: (6) Could not
        resolve host: artii.herokuFLAP.com &gt;</code
      >
    </p>
    <p>
      You can check for this error (hint 1 - the code is
      <code class="sc-cMljjf hbDMZX">ENOTFOUND</code>) to output an equivalent
      message (hint 2 - the <code class="sc-cMljjf hbDMZX">URL</code> object can
      help you get the <code class="sc-cMljjf hbDMZX">host</code> property from
      a url string). Since the error message is showing that the process ended
      with status code “6”, you can and should do the same from your program.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"}
        process.exit(6);</code
      >
    </p>
    <p>Any other errors can be sent as-is through to console as an error.</p>
    <p>
      You can temporarily change the URL in your code to see both of these
      errors.
    </p>
    <ul>
      <li>
        ENOTFOUND:
        <code class="sc-cMljjf hbDMZX"
          >https://artii.herokuappxxxx.com/make?text=curl++this</code
        >
      </li>
      <li>
        Other error:
        <code class="sc-cMljjf hbDMZX"
          >https://artii.herokuapp.com/makexxxx?text=curl++this</code
        >
      </li>
    </ul>
    <blockquote>
      <p>
        Hint: Remember to change the URL back to the working one before
        continuing.
      </p>
    </blockquote>
    <h2 id="step-2-command-line-arguments">Step 2: Command-line arguments</h2>
    <p>
      Instead of hard-coding the URL, it would be nice to pass it to the program
      for more flexibility and reuse. When you’ve completed this upgrade, the
      command to run your program will look like this.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        https://artii.herokuapp.com/make?text=curl++this</code
      >
    </p>
    <p>There are three types of command-line arguments.</p>
    <ul>
      <li>
        arguments with values (e.g. <code class="sc-cMljjf hbDMZX"
          >-o output-file.txt</code
        >)
      </li>
      <li>
        arguments without values, sometimes referred to as “flags” (e.g.
        <code class="sc-cMljjf hbDMZX">-h</code> and
        <code class="sc-cMljjf hbDMZX">--help</code> are often used to output
        help or usage information)
      </li>
      <li>positional arguments (e.g. the url or urls to fetch)</li>
    </ul>
    <p>Throughout the rest of this project you’ll get to try them all.</p>
    <p>
      In order to accept command-line arguments, you’ll want to include a
      package to help you access them. One of the better options is
      <a href="https://www.npmjs.com/package/dashdash">dashdash</a>. Install it
      now using <code class="sc-cMljjf hbDMZX">npm</code>.
    </p>
    <p>
      To get you started quickly, here’s some code you can add to your
      <strong>curl.js</strong>.
    </p>
    <p>
      ``` {style=“color: rgb(248, 248, 242); background: rgb(45, 45, 45);
      font-family: Consolas, Monaco,”Andale Mono“,”Ubuntu Mono“, monospace;
      text-align: left; white-space: pre; word-spacing: normal; word-break:
      normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
      none; padding: 1em; overflow: auto; font-size: 16px;”} const dash =
      require(‘dashdash’);
    </p>
    <p>
      const options = { allowUnknown: true, options: [], }; const parser =
      dash.createParser(options);
    </p>
    <p>
      const opts = parser.parse(options); console.log(‘Options are:’, opts); ```
    </p>
    <p>
      Remember to run your program with some options following the program name.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        &gt; node curl.js -h &gt; node curl.js https://appacademy.io &gt; node
        curl.js -o output.txt https://appacademy.io</code
      >
    </p>
    <h3 id="predefined-options">Predefined options</h3>
    <p>
      Now, try adding a predefined option to the configuration, one that you
      would use to specify the output file name. (This isn’t the
      <em>entire</em> JavaScript file, here. It’s just the snippet of the
      <code class="sc-cMljjf hbDMZX">options</code> variable declaration. Please
      just modify the <code class="sc-cMljjf hbDMZX">options</code> variable.)
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} const options = {
        allowUnknown: true, options: [{ names: ['output', 'o'], type: 'string',
        help: 'file in which to store the fetched content' }], };</code
      >
    </p>
    <p>
      Run the last command again and see how the output differs from before.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        -o output.txt https://appacademy.io Options are: { output: 'output.txt',
        _order: [ { key: 'output', value: 'output.txt', from: 'argv' } ], _args:
        [ 'https://appacademy.io' ] } ...</code
      >
    </p>
    <p>
      Notice that you can get the list of URLs from the
      <code class="sc-cMljjf hbDMZX">_args</code> property. Then, you can get
      the value of the “output” argument that you wrote using the
      <code class="sc-cMljjf hbDMZX">-o</code> signifier through the
      <code class="sc-cMljjf hbDMZX">output</code> property on the
      <code class="sc-cMljjf hbDMZX">opts</code> value.
    </p>
    <p>
      Go ahead and add the option for
      <code class="sc-cMljjf hbDMZX">-h</code> as well. (Hint: the
      <code class="sc-cMljjf hbDMZX">type</code> of a flag option is
      <code class="sc-cMljjf hbDMZX">bool</code>.) Verify it’s working by
      running <code class="sc-cMljjf hbDMZX">node curl.js -h</code>.
    </p>
    <h3 id="url-from-command-line">Url from command-line</h3>
    <p>
      Now change your <code class="sc-cMljjf hbDMZX">url</code> variable (or
      constant) to use the argument instead of a hard-coded string. Then test it
      with several calls to your program with different urls.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        https://appacademy.io &gt; node curl.js
        https://artii.herokuapp.com/make?text=curl++this</code
      >
    </p>
    <p>
      It is pleasing for users if you provide a message when they forget to
      include a required option, such as at least one url. Go ahead and add that
      (obviously before using <code class="sc-cMljjf hbDMZX">args</code> to set
      the <code class="sc-cMljjf hbDMZX">url</code> so the program doesn’t
      crash). Verify by running
      <code class="sc-cMljjf hbDMZX">node curl.js</code>.
    </p>
    <p>
      Also, you may comment out or remove the logging of the options whenever
      you feel you don’t need them any more.
    </p>
    <h3 id="help-message">Help message</h3>
    <p>
      It is useful to map variables to the various properties of the options, if
      you’d like. For example, you might want to do something like this.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} const { help,
        output, _args: urls } = opts;</code
      >
    </p>
    <p>Also output the help information, if that flag is set.</p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} if (help) {
        console.log('node curl.js [OPTIONS] URL'); console.log('OPTIONS:');
        console.log(parser.help().trimRight()); return; }</code
      >
    </p>
    <h2 id="step-3-now-put-it-in-a-file">Step 3: Now, put it in a file</h2>
    <p>
      When the person using your utility specifies that they’d like the content
      of the fetch to be stored in a file, they will do it with one of these
      forms. Of course the string “«file-name»” will be an actual file name and
      not have those fancy guillemets (or those funky double bracket things).
    </p>
    <ul>
      <li><code class="sc-cMljjf hbDMZX">-o «file-name»</code></li>
      <li><code class="sc-cMljjf hbDMZX">--output «file-name»</code></li>
    </ul>
    <p>
      When your program gets that argument, it will <em>not</em> “console log”
      it. Instead, it will write it to the specified file. It should do that
      <em>asynchronously</em>, as well. In fact, node-fetch is designed to work
      directly with writing files, so it has built-in support for
      <a href="https://www.npmjs.com/package/node-fetch#streams"
        >streams with node-fetch</a
      >.
    </p>
    <p>
      Remember to import <code class="sc-cMljjf hbDMZX">fs</code> (you don’t
      need to install, of course, because it is a native part of NodeJS), then
      use the documentation to write the fetched content to the
      <code class="sc-cMljjf hbDMZX">output</code> file, if provided by the user
      calling your program. (Hint:
      <code class="sc-cMljjf hbDMZX">process.stdout</code> works like a file
      stream.)
    </p>
    <p>
      Make sure you can still run without the
      <code class="sc-cMljjf hbDMZX">-o</code> flag or if the filename is
      missing (after the <code class="sc-cMljjf hbDMZX">-o</code> option in the
      command line).
    </p>
    <blockquote>
      <p>
        Test a variety of different commands to ensure all supported variations
        and previous error handling are still working.
      </p>
    </blockquote>
    <h3 id="error-handling-for-writing-files">
      Error handling for writing files
    </h3>
    <p>
      If the file fails to get written, then it should look like this. You need
      to modify your code to make this happen.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        -o node_modules https://artii.herokuapp.com/make?text=curl++this curl:
        (23) Failed writing body</code
      >
    </p>
    <p>
      (Though you’re still using Promises, because you’re saving as a writable
      stream, then it’s at that point that you’re getting this error. Hint:
      <code class="sc-cMljjf hbDMZX">on('error')</code> is a good place to begin
      according to the
      <a
        href="https://nodejs.org/api/errors.html#errors_error_propagation_and_interception"
        >node error handling documentation</a
      >
      under the bullet that starts with “When an asynchronous method is called”
      because “use of the ‘error’ event mechanism is most common for
      stream-based … APIs”.)
    </p>
    <h2 id="congratulations">Congratulations!</h2>
    <p>
      You made it through the minimum project exploring promises and
      command-line arguments. As time and desire permits, you may continue with
      the following bonus rounds to make your program more like the
      <code class="sc-cMljjf hbDMZX">curl</code> command.
    </p>
    <h2 id="bonus-a-setting-an-arbitrary-header">
      Bonus A: Setting an arbitrary header
    </h2>
    <p>
      Have a look at
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Examples"
        >Examples using Fetch</a
      >
      to see how to add headers on an invocation of
      <code class="sc-cMljjf hbDMZX">fetch</code> in the second code example of
      the section. You may also want to check out the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax"
        >Syntax of Fetch</a
      >
      for a property on the object you pass into for the “init” parameter that
      would allow you to set the <em>headers</em> of the request. Or,
      <a href="https://lmgtfy.com/?q=fetch+set+request+headers&amp;s=d"
        >let me DuckDuckGo that for you</a
      >.
    </p>
    <p>
      Use that knowledge to be able to handle one or more of the
      <code class="sc-cMljjf hbDMZX">-H</code> or
      <code class="sc-cMljjf hbDMZX">--header</code> command line option. It’s
      value should have the form “«Header Name»: «Header Value»” like “Accept:
      application/json” or “Content-Type: application/json”.
    </p>
    <h3 id="setting-special-headers">Setting special headers</h3>
    <p>
      Now that you can set arbitrary headers, support the command line arguments
      and their meaning.
    </p>
    <table>
      <thead>
        <tr class="header">
          <th style="text-align: left">Command Line Argument</th>
          <th style="text-align: left">Meaning</th>
          <th style="text-align: left">HTTP Header</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: left">
            <code class="sc-cMljjf hbDMZX">-A «string»</code>
          </td>
          <td style="text-align: left">
            Set the
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent"
              >user agent header</a
            >
          </td>
          <td style="text-align: left">“User-Agent: «string»”</td>
        </tr>
        <tr class="even">
          <td style="text-align: left">
            <code class="sc-cMljjf hbDMZX">-e «URL»</code>
          </td>
          <td style="text-align: left">
            Set the
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer"
              >referer header</a
            >
          </td>
          <td style="text-align: left">“Referer: «URL»”</td>
        </tr>
      </tbody>
    </table>
    <h2 id="bonus-b-capturing-response-headers">
      Bonus B: Capturing response headers
    </h2>
    <p>
      Sometimes the person using the command wants to see the output of the
      metadata of the request, too. That’s where the “–dump-header” flag comes
      into play. When someone issues the command with that flag
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        --dump-header ./headers.txt \
        https://artii.herokuapp.com/make?text=curl++this</code
      >
    </p>
    <p>
      Then it will print out the content of the response like it normally does.
      In addition to that, though, it will create a file named “./headers.txt”
      and put the HTTP response status line and all of the headers of the
      response in it. An example content of the file would look like this.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} HTTP/1.1 200 OK
        Connection: keep-alive Content-Type: text/plain Content-Length: 319
        Server: Goliath Date: Tue, 03 Feb 2019 05:52:55 GMT Via: 1.1 vegur</code
      >
    </p>
    <h2 id="bonus-c-sending-data">Bonus C: Sending data</h2>
    <p>
      When someone adds the <code class="sc-cMljjf hbDMZX">-d «string»</code> or
      <code class="sc-cMljjf hbDMZX">--data «string»</code> flag to the command,
      that should become the body of the HTTP request. So, make it the body of
      your <code class="sc-cMljjf hbDMZX">fetch</code>. Check out the
      <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Syntax"
        >Syntax of Fetch</a
      >
      for a property on the object you pass into for the “init” parameter that
      would allow you to set the <em>body</em> of a request. This should also
      set the method of the request to POST.
    </p>
    <h3 id="overriding-the-method-of-the-request">
      Overriding the method of the request
    </h3>
    <p>
      When someone adds the <code class="sc-cMljjf hbDMZX">-X</code> command
      line argument followed by an HTTP method, then set that method on the
      fetch request. You’ll want to find the property on the “init” parameter
      that would allow you to override the <em>method</em> of the HTTP request.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        -X 'POST' \ -d '{"title": "Sir", "name": "Robin"}' \ -H 'Content-Type:
        application/json' \ https://jsonplaceholder.typicode.com/posts</code
      >
    </p>
    <p>which should result in something like</p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} { "title": "Sir",
        "name": "Robin", "id": 101 }</code
      >
    </p>
    <h2 id="bonus-d-multiple-files-multiple-output-destinations">
      Bonus D: Multiple files, multiple output destinations
    </h2>
    <p>
      Now that you can download a single file, make it like the way
      <code class="sc-cMljjf hbDMZX">curl</code> handles multiple URLs and
      <code class="sc-cMljjf hbDMZX">-o</code> parameters.
    </p>
    <ul>
      <li>Do the transfers in parallel, not one right after another</li>
      <li>
        For each URL provided, a corresponding
        <code class="sc-cMljjf hbDMZX">-o</code> or
        <code class="sc-cMljjf hbDMZX">--output</code> is its target. If there
        are more URLs than there are output targets, the remainder of the
        content gets output to standard out.
      </li>
    </ul>
    <p>Here are some examples to get you used to it.</p>
    <p>Prints both files to standard out</p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        https://artii.herokuapp.com/make?text=curl++this \
        https://artii.herokuapp.com/make?text=curl++that</code
      >
    </p>
    <p>
      Saves the first to the file “first.txt” and prints the second to standard
      out
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        -o first.txt \ https://artii.herokuapp.com/make?text=curl++this \
        https://artii.herokuapp.com/make?text=curl++that</code
      >
    </p>
    <p>
      Saves the first to the file “first.txt” and saves the second to the file
      “second.txt”
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        -o first.txt \ -o second.txt \
        https://artii.herokuapp.com/make?text=curl++this \
        https://artii.herokuapp.com/make?text=curl++that</code
      >
    </p>
    <h2 id="bonus-e-list-globbing">Bonus E: List globbing</h2>
    <p>
      If a person specifies a “list glob”, then expand it to all of the files
      that it represents. A list glob uses curly braces to specify a list.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        https://artii.herokuapp.com/make?text={this,that,the+other}</code
      >
    </p>
    <p>
      The previous statement would “expand” to the following equivalent command.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} &gt; node curl.js
        https://artii.herokuapp.com/make?text=this \
        https://artii.herokuapp.com/make?text=that \
        https://artii.herokuapp.com/make?text=the+other</code
      >
    </p>
    <h2 id="nightmare-round-a-the-progress-meter">
      Nightmare round A: The progress meter
    </h2>
    <p>
      When your utility saves all of its contents into files, then show a
      progress meter for the download. It should show the percent total that it
      is at. You’ll need to look at the “Content-Length” header of the
      <em>response</em> headers. Then, you can get a reader from the response
      body to monitor how much has been read.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} % Total -- -----
        make 18 151M</code
      >
    </p>
    <h2 id="nightmare-round-b-progress-meter-for-multiple-files">
      Nightmare round B: Progress meter for multiple files
    </h2>
    <p>
      What you just did for the download progress meter, do it so that it can
      track multiple files, too.
    </p>
    <p>
      <code
        >{style="color: rgb(248, 248, 242); background: rgb(45, 45, 45);
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        text-align: left; white-space: pre; word-spacing: normal; word-break:
        normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens:
        none; padding: 1em; overflow: auto; font-size: 16px;"} % Total -- -----
        make 18 151M make 14 111M</code
      >
    </p>
    <p>Did you find this lesson helpful?</p>
    <p>No</p>
    <p>Yes</p>
    <p><strong>✔︎ Submit Project</strong></p>
    <p>
      Archive your file into a <strong>.zip</strong> folder and click
      <strong>Submit Project</strong> to upload.
    </p>
    <p>Solutions become available after uploading.</p>
  </body>
</html>
